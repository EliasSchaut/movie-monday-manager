# This file was generated. Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

"Indicates exactly one field must be supplied and this field must not be `null`."
directive @oneOf on INPUT_OBJECT

type AuthModel {
    "The barrier token."
    barrier_token: String
    "Indicates if user is admin."
    is_admin: Boolean
}

type MovieHistoryModel {
    id: Int!
    imdb_id: String
    lang_meta: String!
    plot_overview: String
    poster_path: String
    release_date: String
    title: String!
    tmdb_id: Int
    watched_at: DateTime!
}

type MovieModel {
    actors: [String!]
    adult: Boolean
    budget: Int
    director: String
    genres: [String!]
    homepage: String
    id: Int!
    imdb_id: String
    imdb_rate: String
    lang_meta: String!
    metascore: String
    original_language: String
    original_title: String
    plot_overview: String
    poster_path: String
    production_companies: [String!]
    production_countries: [String!]
    proposer: UserModel!
    rank: Float!
    release_date: String
    revenue: Int
    rotten_tomato_rate: String
    runtime: Int!
    spoken_languages: [String!]
    tagline: String
    title: String!
    tmdb_id: Int
    tmdb_rate: Int
    writer: String
}

"Movie with reduced information as on result of a search query"
type MovieSearchItemModel {
    imdb_id: String
    lang_meta: String!
    plot_overview: String
    poster_path: String
    release_date: String
    title: String!
    tmdb_id: String
}

type MovieSearchModel {
    items: [MovieSearchItemModel!]!
}

type Mutation {
    auth_register(user_input_data: UserInputModel!): UserModel!
    auth_user_pw_reset(user_pw_reset_input_data: UserPwResetInputModel!): UserModel!
    "Request a password reset for a user. A new challenge will sent to the user's email. Returns true if the request was successful."
    auth_user_pw_reset_request(username: String!): Boolean!
    auth_verify(challenge: String!): UserModel!
    history_add(history_input: MovieHistoryInputModel!): MovieHistoryModel!
    history_delete(movie_id_input: MovieIdInputModel!): MovieHistoryModel!
    movie_create(external_id_input: MovieExternalIdInputModel!): MovieModel!
    movie_delete(movie_id_input: MovieIdInputModel!): MovieModel!
    movie_delete_proposed(movie_id_input: MovieIdInputModel!): MovieModel!
    update(server_input: ServerSettingsInputModel!): ServerSettingsModel!
    user_delete: UserModel!
    user_update(user_update_input_data: UserUpdateInputModel!): UserModel!
    watchlist_add_or_update(watchlist_input: WatchlistInputModel!): WatchlistItemModel!
    watchlist_delete(movie_id_input: MovieIdInputModel!): WatchlistItemModel!
}

type Query {
    auth_sign_in(email: String!, password: String!): AuthModel!
    history(movie_id_input: MovieIdInputModel!): MovieHistoryModel!
    history_find_many: [MovieHistoryModel!]!
    movie(movie_id_input: MovieIdInputModel!): MovieModel!
    movie_find_many: [MovieModel!]!
    movie_search(movie_search_input: MovieSearchInputModel!): MovieSearchModel!
    "Get server Information"
    server: ServerModel!
    user: UserModel!
    vote(movie_id_input: MovieIdInputModel!): VoteModel!
    vote_create(vote_input: VoteInputModel!): VoteModel!
    vote_delete(movie_id_input: MovieIdInputModel!): VoteModel!
    vote_user: [VoteModel!]!
    watchlist: WatchlistModel!
    watchlist_auto_info: WatchlistModel!
}

"Server Information"
type ServerModel {
    "Description of the server"
    desc: String
    "Unique id number of server used for comparison"
    id: Int!
    "Unique name of the server"
    name: String!
    "Oauth information"
    oauth: [ServerOauthModel!]
    "Origin URL of the server"
    origin: String
    resolve_oauth(name: String, secret_api_key: String): [ServerOauthModel!]!
    settings: ServerSettingsModel!
    "Visible title of the server"
    title: String!
}

"Oauth information"
type ServerOauthModel {
    "Client id of oauth"
    client_id: String
    "Hidden client secret of oauth. Only accessible when using secret-api-key."
    client_secret: String
    "Unique id number of server used for comparison"
    id: Float
    "Name of oauth"
    name: String
}

type ServerSettingsModel {
    "Enables or disables whether a message should send via a discord webhook on watchlist creation"
    discord_auto: Boolean!
    "The message, the webhook should send. Term <watchlist> will be replaced by actual watchlist"
    discord_msg: String
    "Discord Webhook Link"
    discord_webhook: String
    "Maximal numbers of movies that can be proposed"
    max_movies: Int!
    "Maximal number of movies a user can propose"
    max_proposals: Int!
    "Maximal votes a user can give"
    max_votes: Int!
    "Gap time in minutes between movies added to the watchlist in a auto creation round"
    movie_gap_mins: Int!
    "Indicates if the end time of a movie will be rounded to the next five mins"
    round_to_5mins: Boolean!
    "Enables or disables the automatic creation of the watchlist"
    watchlist_auto: Boolean!
    "Number of movies that will be added to watchlist, if watchlist is on auto mode"
    watchlist_num_of_movies: Int!
    "Cron string that specifies the interval, when the watchlist creation is triggered"
    watchlist_schedule_creation: String!
    "Cron string that specifies the start time of the first movie added"
    watchlist_schedule_start: String!
}

type UserModel {
    "Link to profile picture of user. Only public if profile is public"
    avatar: String
    "Short bio of user. Only public if profile is public"
    bio: String
    "Challenge string used for password reset and account verification"
    challenge: String
    "Unique private email of user used to login and receive emails"
    email: String
    "Indicates whether the user wants to receive non essential emails"
    email_opt_in: Boolean
    "First name of user. Only public if profile is public"
    first_name: String
    "Unique id number of user used for comparison"
    id: ID!
    "Indicates whether the user is an admin"
    is_admin: Boolean
    "Last name of user. Only public if profile is public"
    last_name: String
    "Hashed password of user used for login"
    password: String
    "Indicates whether the user wants their profile to be public"
    profile_public: Boolean
    "Indicates whether a password reset was requested"
    pw_reset: Boolean
    "Unique id number of server on which the user is registered"
    server_id: Float
    "Unique public username of user used to display to others"
    username: String!
    "Indicates whether the user account is verified"
    verified: Boolean
    votes: [VoteModel!]
}

type VoteModel {
    movie_id: String!
    proposer_id: Int!
    rank: Int!
}

type WatchlistItemModel {
    end_time: DateTime!
    interested_users: [UserModel!]!
    movie: MovieModel!
    start_time: DateTime!
}

type WatchlistModel {
    items: [WatchlistItemModel!]!
}

"A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format."
scalar DateTime

input MovieExternalIdInputModel {
    imdb_id: String
    tmdb_id: Int
}

input MovieHistoryInputModel {
    movie_id: String!
    watched_at: DateTime = "2024-08-26T18:15:10.002Z"
}

input MovieIdInputModel {
    movie_id: String!
}

input MovieSearchInputModel {
    query: String!
}

input ServerSettingsInputModel {
    "Enables or disables whether a message should send via a discord webhook on watchlist creation"
    discord_auto: Boolean
    "The message, the webhook should send. Term <watchlist> will be replaced by actual watchlist"
    discord_msg: String
    "Discord Webhook Link"
    discord_webhook: String
    "Maximal numbers of movies that can be proposed"
    max_movies: Int
    "Maximal number of movies a user can propose"
    max_proposals: Int
    "Maximal votes a user can give"
    max_votes: Int
    "Gap time in minutes between movies added to the watchlist in a auto creation round"
    movie_gap_mins: Int
    "Indicates if the end time of a movie will be rounded to the next five mins"
    round_to_5mins: Boolean
    "Enables or disables the automatic creation of the watchlist"
    watchlist_auto: Boolean
    "Number of movies that will be added to watchlist, if watchlist is on auto mode"
    watchlist_num_of_movies: Int
    "Cron string that specifies the interval, when the watchlist creation is triggered"
    watchlist_schedule_creation: String
    "Cron string that specifies the start time of the first movie added"
    watchlist_schedule_start: String
}

input UserInputModel {
    avatar: String
    bio: String
    email: String!
    email_opt_in: Boolean = false
    first_name: String!
    last_name: String!
    password: String!
    profile_public: Boolean = false
    username: String!
}

input UserPwResetInputModel {
    "Challenge string used for password reset and account verification"
    challenge: String!
    "New password of user used for login"
    password: String!
    "ID of user to reset password"
    user_id: String!
}

input UserUpdateInputModel {
    avatar: String
    bio: String
    email: String
    email_opt_in: Boolean
    first_name: String
    last_name: String
    password: String
    profile_public: Boolean
    username: String
}

input VoteInputModel {
    movie_id: String!
    rank: Int!
}

input WatchlistInputModel {
    movie_id: String!
    start_time: DateTime!
}
